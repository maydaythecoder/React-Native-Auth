Thanks for sharing the errors. I'll research the best tools and methods for tracking errors and crashes in a React Native Expo Go environment, focusing on development but also mentioning options for production. I'll also investigate specific solutions for the errors you've encountered, including issues related to FinalizationRegistry, missing default exports in routes, SplashModule errors, and stack overflows. I'll get back to you with recommendations and troubleshooting steps.
Tracking and Troubleshooting Errors in React Native Expo (Expo Go & Production)
Expo’s Built-in Logging and Error Overlay (Development)
Expo provides robust built-in logging during development through the React Native LogBox system. In Expo Go (the development client), runtime errors appear as a RedBox with an error message and stack trace on-screen, and the same stack trace is shown in your terminal (Errors and warnings - Expo Documentation) (Errors and warnings - Expo Documentation). This makes it easy to identify where a crash occurred. You can also use the in-app developer menu (shake device or press Ctrl+M/⌘+M) to access debugging options like reloading and remote debugging (Debugging · React Native). Key points for using Expo’s built-in logging effectively:
Console Logs: Use console.log, console.warn, and console.error for custom messages. Warnings (YellowBox) and errors (RedBox) will surface in the app UI during development (Errors and warnings - Expo Documentation). This helps catch issues early.
Stack Traces: The RedBox overlay and terminal log include stack traces pointing to the file and line where the error occurred (Errors and warnings - Expo Documentation). Use this information to pinpoint the source of the problem.
Error Boundaries: In development, all uncaught exceptions are shown (there’s no way to disable the error overlay). For testing, you can catch errors in components using React error boundaries, but note that in dev mode the RedBox will still show for unhandled errors (Debugging · React Native).
Clearing/Reloading: Sometimes errors persist due to caching. Running expo start -c clears the Metro bundler cache, which can resolve issues like stale code or module resolution errors. Also try fully closing and reopening Expo Go if it becomes unresponsive.
By relying on these tools, you can debug most issues in development. If an error is hard to trace, follow Expo’s advice: isolate recent code changes to find what triggers the error (Debugging runtime issues - Expo Documentation), and search for the exact error message on forums or Stack Overflow (Debugging runtime issues - Expo Documentation). This built-in logging is usually enough for development debugging (Debugging runtime issues - Expo Documentation).
Integrating Sentry for Error Monitoring (Production & Development)
For deeper insights and crash reporting, Sentry is a popular third-party service that works well with Expo. Sentry captures exceptions (with stack traces, device info, app version, etc.) and aggregates them on a dashboard (Using Sentry - Expo Documentation), allowing you to monitor errors in real time. To set up Sentry in an Expo project:
Install Sentry SDK: Expo SDK 50+ uses the unified Sentry React Native SDK. First, sign up on Sentry and get a DSN (Data Source Name). Then in your project, install Sentry – e.g. run npx expo install @sentry/react-native. In your app.json, add the Sentry config plugin:

 "expo": {
  "plugins": [
    [
      "@sentry/react-native/expo",
      {
        "organization": "<your Sentry org>",
        "project": "<your Sentry project>",
        "url": "https://sentry.io/"
      }
    ]
  ]
}
 This ensures source maps and native integration are configured at build time (Using Sentry - Expo Documentation). You’ll also want to set an auth token for Sentry if you plan to upload source maps on EAS Build (e.g. set the SENTRY_AUTH_TOKEN in your build environment) (Using Sentry - Expo Documentation).


Initialize Sentry in your App: Import Sentry and call Sentry.init() as early as possible in your app startup (for example, in your root component or global layout). Use your DSN and appropriate options:

 Sentry.init({
  dsn: "<YOUR_DSN_HERE>",
  debug: true, // verbose logging in development
  tracesSampleRate: 1.0 // or adjust in production
});
 If you use Expo Router, you can integrate it to track navigation routes in Sentry (Using Sentry - Expo Documentation). Sentry will automatically catch unhandled exceptions and promise rejections. In development you might set debug: true to verify events are sent, and disable it in production (Using Sentry - Expo Documentation).


Verify and Use: Run your app and intentionally trigger an error (e.g. throw new Error("Test Sentry")) to ensure it appears on Sentry’s dashboard. Sentry will group similar errors and show stack traces, making it easier to fix issues. You can also add custom logging with Sentry.captureException(error) or attach user feedback/context as needed.


Sentry is particularly useful for production builds, where the RedBox isn’t available. With Sentry integrated, you get alerts for crashes your users encounter and detailed reports to debug them (Debugging runtime issues - Expo Documentation) (Debugging runtime issues - Expo Documentation). Keep in mind that in the Expo Go development client, Sentry’s native crash handling may not fully work (Expo Go doesn’t include the Sentry native module), but Sentry can still capture JavaScript errors in development. For full native crash support (e.g. crashes outside the JS thread), you’d use a custom development build or production build of your app.
Using Firebase Crashlytics for Crash Reporting
Google’s Firebase Crashlytics is another service for tracking crashes and non-fatal errors, but its integration in Expo requires extra steps. Crashlytics is not supported with the plain Expo Go app, because it relies on native modules that Expo Go doesn’t include (Using Firebase - Expo Documentation) (Using Firebase - Expo Documentation). To use Crashlytics in Expo, you’ll need to create a Development Build or go to the Bare/Prebuild workflow:
Setup React Native Firebase: Expo projects can use the React Native Firebase libraries via config plugins. First, install the base package: npx expo install @react-native-firebase/app, and the Crashlytics module: npx expo install @react-native-firebase/crashlytics. Also install expo-dev-client if you plan to run it in development (expo install expo-dev-client) (Using Firebase - Expo Documentation). Ensure your app is configured to use the dev client (e.g. run npx expo start --dev-client for development builds).


Configure Plugins: In your app.json/app.config.js, add the Firebase config plugins. For example:

 "expo": {
  "plugins": [
    "@react-native-firebase/app",
    "@react-native-firebase/crashlytics"
  ]
}
 Also create a firebase.json in the project root with Crashlytics settings. For development, you might enable debug mode to force Crashlytics to send reports. For example:

 {
  "react-native": {
    "crashlytics_debug_enabled": true,
    "crashlytics_auto_collection_enabled": true
  }
}
 (This ensures Crashlytics will send reports even in a debug build, and auto-collect crash reports without awaiting user opt-in.)


Build the App: Use EAS Build or run expo run:android / expo run:ios after prebuilding to get a custom build that includes Crashlytics. The managed workflow won’t include Crashlytics by default (Using Firebase - Expo Documentation). For example, on EAS you’d do eas build --profile development (for a dev client) or a production build. Install the resulting build on your device/emulator.


Verify Crashlytics: Cause a test crash or use Crashlytics().log("Test log") and Crashlytics().crash() to verify it’s working. Then check the Firebase console Crashlytics section for the report. In a development build, you can also check if Crashlytics is initialized by calling crashlytics().isCrashlyticsCollectionEnabled in your app and logging the result (react native firebase crashlytics in expo development build - Stack Overflow).


Using Crashlytics provides automatic reports for native crashes and JS errors that crash the app, similar to Sentry. However, remember that in Expo Go you cannot use Crashlytics – you must use a custom build. This is an advanced setup (requiring the React Native Firebase libraries and EAS Build), so consider if Sentry or other JS-only error trackers suffice for your needs in production if you wish to avoid a custom build.
Troubleshooting Common Errors in Expo Go
Even with good tracking tools, you’ll need to diagnose and fix the errors themselves. Below are several common errors in an Expo/React Native environment (including Expo Router and SDK-related issues) and how to address them. In general, when troubleshooting in Expo Go, use the log output and stack traces to locate the source, and apply fixes or workarounds as needed.
“ReferenceError: Property 'FinalizationRegistry' doesn't exist”
Cause: This error means the JavaScript runtime doesn’t recognize the FinalizationRegistry API. In React Native, FinalizationRegistry is available when using the Hermes engine (and on Node.js 14+ with JSC). Expo apps should normally have Hermes enabled (it’s default in recent SDKs). A common trigger for this error was a dependency that assumed FinalizationRegistry existed. For example, an outdated version of @react-aria/utils (used by some UI libraries like Gluestack) caused this error in Expo apps until it was patched (javascript - ReferenceError: Property 'FinalizationRegistry' doesn't exist [Component Stack] - Stack Overflow).
Solutions: Ensure your environment and libraries support FinalizationRegistry:
Use Hermes JS Engine – Verify that Hermes is enabled for your Expo app. In your app.json, under "expo", set "jsEngine": "hermes" and rebuild the app. Hermes provides FinalizationRegistry natively (javascript - ReferenceError: Property 'FinalizationRegistry' doesn't exist [Component Stack] - Stack Overflow). (Most Expo SDK 48+ projects use Hermes by default, but double-check in case it was turned off.)
Update Dependencies – If you use a library like Gluestack UI or React Aria that might polyfill low-level APIs, update it to the latest version. The maintainers likely fixed the issue in a patch (e.g. @react-aria/utils@3.28.1 resolved this error) (javascript - ReferenceError: Property 'FinalizationRegistry' doesn't exist [Component Stack] - Stack Overflow). Remove any workarounds or overrides pinning an older version, then reinstall packages to get the fix.
Expo SDK and React Native Version – Make sure you’re on a recent Expo SDK and React Native version. FinalizationRegistry was added in RN 0.66+ and Node 14+, so using an older SDK may lack support (javascript - ReferenceError: Property 'FinalizationRegistry' doesn't exist [Component Stack] - Stack Overflow). Upgrading Expo (expo upgrade) will update RN and can resolve the issue if it was due to an outdated JS runtime.
Clear Metro Cache – Sometimes Metro bundler might cache an environment without the API. Run expo start -c to clear the cache (javascript - ReferenceError: Property 'FinalizationRegistry' doesn't exist [Component Stack] - Stack Overflow) after making the above changes.
Run Expo Doctor – If the issue persists, run npx expo doctor to check for inconsistencies in your project. Also, ensure that no other polyfill is unintentionally overriding global objects.
After these steps, restart your app. In the case of the Gluestack UI issue, the library authors confirmed that updating the dependency and reinstalling resolved the error (javascript - ReferenceError: Property 'FinalizationRegistry' doesn't exist [Component Stack] - Stack Overflow). With Hermes enabled and packages updated, FinalizationRegistry should be defined and the ReferenceError will disappear.
“Route "..." is missing the required default export”
Cause: This error comes from Expo Router (file-based routing). It indicates that a route file in your app’s app directory doesn’t have a default export. In Expo Router, every screen/component file must export default a React component. If a file only uses named exports or is empty, the router can’t find a screen to render, hence the error. The message often specifies the file path (e.g. Route "./(tabs)/X.tsx" is missing the required default export) (react-native-keyboard-controller causes crash in Expo (Managed Workflow) · Issue #2595 · FaridSafi/react-native-gifted-chat · GitHub). Another related warning is “Too many screens defined... Route 'XYZ' is extraneous” (react-native-keyboard-controller causes crash in Expo (Managed Workflow) · Issue #2595 · FaridSafi/react-native-gifted-chat · GitHub), which can happen if you accidentally have duplicate route definitions or a component file inside a folder that already serves as a layout.
Solutions: Fixing this involves correcting your file structure and exports:
Add a Default Export – Open the file mentioned in the error (e.g. app/(tabs)/X.tsx) and ensure it has a export default component. For example:
 // In app/(tabs)/X.tsx
import { View, Text } from 'react-native';
export default function X() {
  return <View><Text>Screen X</Text></View>;
}
 Only one default export should exist per route file. This satisfies Expo Router’s requirement for a component screen export.
Check for Typos/Mistakes – Make sure the file name and folder placement follow Expo Router conventions. A common mistake is placing utility or helper files in the app directory. Every file in app is assumed to be a route or layout (Create pages with Expo Router - Expo Documentation). So, if you have non-component files there, move them out or prefix them with an underscore (which Expo ignores in routing).
Remove Extraneous Files – If you see a warning about an extraneous route, it means you might have defined the same route twice. For instance, you might have app/(tabs)/explore.tsx and also an explore screen defined elsewhere, causing a conflict. Remove or rename the duplicate so that each route path maps to only one file. Expo Router will then be able to assemble the navigation structure without confusion.
Re-run Metro – After fixing the files, reload the app (r in the terminal or Reload in dev menu). If the error still appears, restart the dev server. Sometimes Metro needs a restart to pick up new file exports.
Expo Router’s error messages guide you to the file that needs attention. Once you add the missing default export (or remove the offending file), the warning should disappear. You’ll then see your screen rendering normally. Following Expo’s documentation for file-based routing structure can help prevent such errors – for example, always use default exports for screens (Create pages with Expo Router - Expo Documentation) (Create pages with Expo Router - Expo Documentation).
“Unhandled promise rejection [RangeError: Maximum call stack size exceeded]”
Cause: A “maximum call stack size exceeded” RangeError means the app has entered an infinite recursion or endless loop of function calls. Essentially, the call stack (which tracks nested function calls) grows until it hits a limit. This often happens from a bug in code – e.g. a recursive function with no base case, two components endlessly re-rendering each other, or an effect that continuously triggers itself. In JavaScript, a function calling itself without stop will eventually throw this error (JavaScript RangeError: Maximum Call Stack Size Exceeded). The twist here is the message is an unhandled promise rejection, meaning the infinite loop was likely happening inside a Promise or async function that never resolves (hence it was reported as an unhandled rejection).
Troubleshooting Steps: Because the stack overflow error doesn’t always pinpoint the exact code line (the stack trace may just show repeating frames), you have to hunt for the logical mistake:
Identify Recent Changes – Think about what code might cause a recursive call. Common culprits: recursively calling functions, deeply nested loops, or state updates in a useEffect that trigger the effect again. If the error started after adding a certain feature, inspect that code for any function that calls itself (directly or indirectly).
Insert Breakpoints/Logs – Use console.log strategically to see what runs repeatedly. For example, log at the start of suspect functions or effects. If you see a log line flooding continuously right before the crash, you’ve found the loop.
Isolate the Loop – A binary search approach can help: comment out or disable chunks of code (e.g. remove a component, or a feature flag) to see when the error stops. Narrow it down until you find the offending function or component. Once isolated, analyze why it recurses. For instance, a component that updates state on render without a termination condition can cause an endless re-render loop.
Common Expo Quirk – Note that Expo Go may surface this error in cases that wouldn’t crash a plain React Native app. One developer reported that having a very large constants file (nearly 486 exported constants) caused this error in Expo Go, while running the same code in a pure RN environment did not (react native - Troubleshooting Maximum Stack Call Size Exceeded Error in Expo App - Stack Overflow). The fix there was to remove or reduce that file. So, if nothing obvious is recursive, consider if some unusually large or deeply nested structure is blowing the stack in the Expo environment.
Fix the Code – After identifying the cause, implement a fix. Add a terminating condition to recursive functions, throttle or debounce rapid repeated calls, or restructure state updates to avoid back-and-forth updates. For example, if two state setters are calling each other, refactor so they don’t endlessly ping-pong.
Once you’ve made changes, reload the app and test thoroughly. The error should no longer occur if the infinite loop is resolved. Keep an eye on the console for any rapidly repeating messages as a sign of a potential loop. Writing defensive code (like guarding against multiple calls) can prevent such issues. Remember that a stack overflow error is always due to a runaway execution – finding what’s running uncontrollably is the key to fixing it.
“Unhandled promise rejection [TypeError: SplashModule.internalMaybeHideAsync is not a function]”
Cause: This error is related to Expo’s Splash Screen API. It indicates that the app tried to call a function on the native splash screen module that isn’t present. In newer Expo SDKs, SplashModule.internalMaybeHideAsync is an internal method used when hiding or configuring the splash screen. If it says “is not a function (it is undefined)”, it means the native module didn’t have that method. This often happens in the Expo Go environment or if there’s a version mismatch:
In Expo Go: The managed Expo Go app might not support the latest splash-screen functions. For example, Expo SDK 49+ introduced an updated splash-screen module that Expo Go (especially older versions) doesn’t fully implement. Calling certain methods (like SplashScreen.setOptions or the internal hide) in Expo Go can throw a no-function error (SplashScreen.setOptions causes "(NOBRIDGE) ERROR TypeError: SplashModule.setOptions is not a function" in Expo Go · Issue #33098 · expo/expo · GitHub). Expo addressed this by preventing those calls in Expo Go in subsequent patches.
In Custom Builds/Production: If you see this in an EAS build or standalone app, it could mean there’s an issue with the native module integration. One possibility is that you have multiple versions of expo-splash-screen installed or an incomplete linking. For instance, a user found that the real cause was a missing native module (AsyncStorage) which was crashing initialization – once that was fixed, the splash error went away (SplashModule.internalMaybeHideAsync is not a function (it is undefined) · Issue #33316 · expo/expo · GitHub). Another scenario is an outdated expo-splash-screen library in your project vs. the native code.
Solutions:
Ensure Correct Expo SDK Version – Make sure your Expo SDK and Expo Go app are in sync. If you updated the SDK, update Expo Go to the latest version available. In development builds, install the latest expo-splash-screen package that matches your SDK. Expo often fixes such issues in minor releases, so upgrading to the newest SDK (or patch) can resolve the error.
Avoid Unsupported Calls in Expo Go – If you’re only seeing this in Expo Go (development), you can ignore or work around it, because Expo Go manages the splash screen automatically. For example, one workaround is to use the SplashScreen utility from expo-router (if you use Expo Router) instead of calling Expo’s splash-screen directly in dev (SplashScreen.setOptions causes "(NOBRIDGE) ERROR TypeError: SplashModule.setOptions is not a function" in Expo Go · Issue #33098 · expo/expo · GitHub). In practice, you might simply not call SplashScreen.hideAsync() when running in Expo Go. The Expo docs suggest that Expo Go doesn’t need manual hiding – it’ll show the splash until the app is ready.
Verify Installation in Builds – For standalone apps or dev clients, run an adb logcat (Android) or use Xcode Console (iOS) to see if there are related errors. The splash module error could be a symptom of another native module failing. In one case, adding @react-native-async-storage/async-storage to the project (because it was indirectly required) fixed the crash (SplashModule.internalMaybeHideAsync is not a function (it is undefined) · Issue #33316 · expo/expo · GitHub). So check if all native modules are properly installed and listed in package.json (Expo config plugins only autolink modules present in dependencies).
Check for Duplicate Modules – Use npm ls expo-splash-screen (or npm why expo-splash-screen) to ensure only one version is installed. If two versions are present (perhaps via another dependency), align them to one. A duplicate could confuse which implementation is used, leading to missing methods (SplashModule.internalMaybeHideAsync is not a function (it is undefined) · Issue #33316 · expo/expo · GitHub).
Update Splash Screen Usage – Make sure you follow the latest Expo Splash Screen documentation for your SDK. For SDK 49/50+, the splash screen is configured via app.json and usually doesn’t require manual hide if you use the default behavior. If you are manually controlling it, call SplashScreen.preventAutoHideAsync() at app start and ...hideAsync() when ready. Ensure these are awaited properly. If the internal method error persists, consider removing custom splash code and rely on Expo’s auto-hide (which hides the splash once React mounts). This can bypass the problematic call entirely.
After applying fixes, test the app in a development build or on a simulator. If using Sentry, you might have seen this error reported there; check again after fixes to confirm it’s gone. In summary, this error is telling you the native splash module couldn’t be invoked. Aligning versions and adjusting your usage of the splash API will resolve it. In many cases, simply not calling splash hide in Expo Go (or upgrading Expo) is enough to avoid the issue (SplashScreen.setOptions causes "(NOBRIDGE) ERROR TypeError: SplashModule.setOptions is not a function" in Expo Go · Issue #33098 · expo/expo · GitHub), while in production builds ensuring all native modules are correctly included will prevent the crash.
Best Practices Summary
When developing with Expo (especially using Expo Go), leverage the built-in error overlay and logs to catch issues early. For production monitoring, set up a tool like Sentry (easy integration with managed Expo) or Crashlytics (if you need native crash details, using a dev client or bare build) to get reports from real users (Debugging runtime issues - Expo Documentation) (Debugging runtime issues - Expo Documentation). Always keep your Expo SDK and libraries up to date, as many error messages (like the ones above) are resolved by patch updates or proper configuration. Finally, approach debugging systematically: read the stack traces, search for the error message online, isolate the problem code, and apply fixes iteratively (Debugging runtime issues - Expo Documentation). With these tools and methods, you can track down even the thorny issues and ensure your React Native app (Expo managed or otherwise) runs smoothly in both development and production.

